grammar fr.n7.PrototypeExplo with org.eclipse.xtext.common.Terminals

generate prototypeExplo "http://www.n7.fr/PrototypeExplo"
Map: 'map' name=ID 'elements' explorer=Explorer elements+=MapElements+;


/*E3 E6*/
Explorer: 'explorer' name=STRING 'maxSize' maxSize=INT 'items' items+=ConditionalItem* 'knowledges' knowledges+=ConditionalKnowledge*;

MapElements: Place | Path;

DescribableElements: MapElements | Knowledge | Item;

Description: description=STRING | condition=ConditionID description=STRING;


ConditionalItem: 'condition' condition=ConditionID 'for' item=ItemID;

/*E5 E40 E41 E42*/
Item: 'item' name=STRING 'description' description=Description 'size' size=INT 'visible' isVisible=Bool ('transformabilityConditions' transformabilityCondition=ConditionalItem)?;


ConditionalKnowledge: 'condition' condition=ConditionID 'for' knowledge=KnowledgeID;

/*E3 */
Knowledge: 'knowledge' name=STRING 'description' description=Description 'VisibleCondition' visibleCondition=ConditionID;



/*E7 E14*/
Place: 'place' name=STRING 'description' description=Description 'type' type=PlaceType 'canPlaceItem' canPlaceItem=Bool 'paths' paths+=PathID+ ('items' items+=ItemID+)? ('knowledges' knowledges+=KnowledgeID+)? ('NPCs' npcs+=NPCID+)?;

/*E8 */
PlaceType: normal = 'normal'
	| begin = 'begin'
	| end = 'end'
;

/*E9 E10 E11 E16 E20*/
Path: 'path' name=STRING 'description' description+=Description 'visibleCondition' visibleCondition=Condition 'isOpened' isOpened=Bool 'isObligatory' isObligatory=Bool ('transformabilityConditions' transformabilityCondition=ConditionalItem)? 'extremity1' startingPlace=PlaceID 'extremity2' finishingPlace=PlaceID ('items' items+=ConditionalItem+)? ('knowledges' knowledges+=ConditionalKnowledge+)? ('itemsConsumed' itemsConsumed+=ConditionalItem+)?;


/*Type booléen */
Bool: true = 'true'|false = 'false';

/*E25 */
NPC: 'npc' name=STRING 'isObligatory' isObligatory=Bool 'visibleCondition' visibleCondition=ConditionID 'initialChoices' initialChoice+=BeginningChoice+;

/*E23 */
Condition: 'condition' name=STRING 'formula' formula=(NormalDisjunctiveForm | Bool);

/* Description des conditions*/
Comparator: lt='<' | gt='>' | lte='<=' | gte='>=' | eq='=' | neq='!=';
Negation: 'not';
AtomicCondition: Negation? ((item=Item comparateur=Comparator constante=INT )| Knowledge);
Conjunction: conditions += AtomicCondition ('and' conditions += AtomicCondition)*;
NormalDisjunctiveForm: conjunctions += Conjunction ('or' conjunctions += Conjunction)*;


/* E30 */
Choice: 'choice' name=STRING 'condition' condition=ConditionID 'endingCondition' endingCondition=ConditionID 'actions' actions+=ConditionnalAction+ 'suivant' suivant=ChoiceID;

BeginningChoice: 'beginning' Choice;

ChoiceType: normal = 'normal'
	| begin = 'begin'
	| end = 'end'
;

ConditionalChoice: 'condition' condition=ConditionID 'for' Choice=ChoiceID;
ProposedChoice: {ProposedChoice} ChoiceID | ConditionalChoice;

Action: 'action' name=STRING ('items' items+=ConditionalItem+)? ('knowledges' knowledges+=ConditionalKnowledge+)? ('itemsConsumed' itemsConsumed+=ConditionalItem+)?;

ConditionnalAction: 'conditionnalAction' condition=ConditionID ('precedentActions' precedentActions+=ActionCondition+)? 'for' action=ActionID;


/*Définition de forme normale disjonctive d'actions, pour les actions proposées */
ActionAtomicCondition: Negation? choice=ChoiceID;
ActionConjunction: conditions += ActionAtomicCondition ('and' conditions += ActionAtomicCondition)*;
ActionNormalDisjunctiveForm: conjunctions += ActionConjunction ('or' conjunctions += ActionConjunction)*;
ActionCondition: ActionNormalDisjunctiveForm;

/*En soit inutile, pour se repérer plus facilement */
ItemID: STRING;
KnowledgeID: STRING;
ConditionID: STRING;
PlaceID: STRING;
PathID: STRING;
NPCID: STRING;
ChoiceID: STRING;
ActionID: STRING;












