grammar fr.n7.PrototypeExplo with org.eclipse.xtext.common.Terminals

generate prototypeExplo "http://www.n7.fr/PrototypeExplo"
/*La map a un nom pour l'identifier dans les OCL*/
MainMap: 'map' name=MapID
	'elements' '{' elements += MapElements+ '}'
;
/*L'objet MapElements sert à pouvoir énumérer les objets de la carte dans n'importe quel ordre. */
MapElements: Explorer | Place | Item | Path | NPC | Choice | Action | Condition | Knowledge;

/*E3 E6*/
Explorer: 'explorer' name=ExplorerID /*Dora par défaut*/
	'maxSize' maxSize=INT /*La constante qui limite la taille cumulée des objets portés */
	& ('items' '{' items+=ItemID+ '}')? /*Le deux champs optionnels permettent aussi de créer les attributs dans le méta-modèle */
	& ('knowledges' '{' knowledges+=Knowledge+ '}')? /* */
;



Description: description=STRING 'with' 'condition' condition = Condition/*La description dépend de condition */
;




Item: 'item' name=STRING 
	'description' description=Description 
	& 'size' size=INT 
	& 'visibleCondition' visibleCondition=Condition
	& ('transformabilityConditions' '{' transformabilityCondition=ConditionalItem '}')? /*Si la liste est vide, l'item ne peut pas se transformer. */
;

ConditionalItem: item=ItemID  /*J'ai hésité à mettre 'item' au début, mais cet élément est toujours précédé d'un mot clé avec item dedans quand il est appelé ailleurs. */
	'with' 'condition' condition=Condition
;


/*E3 */
Knowledge: 'knowledge' name=STRING 
	& 'description' description=Description 
	& 'visibleCondition' visibleCondition=Condition
;


ConditionalKnowledge: knowledge=KnowledgeID
	'with' 'condition' condition=Condition
;


/*E7 E14*/
Place: 'place' name=STRING 
	'description' description=Description 
	& 'type' type=PlaceType 
	& 'placeItemCondition' placeItemCondition=Condition
	& 'paths' '{' paths+=PathID+ '}'
	& ('items' '{' items+=ItemID+ '}')? 
	& ('knowledges' '{' knowledges+=KnowledgeID+ '}')? 
	& ('NPCs' '{' npcs+=NPCID+ '}')?
;

/*Cela empèche techniquement un lieu d'être à la fois un début et une fin */
PlaceType: normal = 'normal'
	| begin = 'begin'
	| end = 'end'
;

/*Il faut orienter les chemins par défaut, car il faut être capable de séparer les deux extrémités.*/
Path: 'path' name=STRING 
	'description' description+=Description 
	& 'visibleCondition' visibleCondition=Condition
	& 'openedCondition' openedCondition=Condition
	& 'obligatoryCondition' obligatoryCondition=Condition
	& 'extremity1' startingPlace=PlaceID 
	& 'extremity2' finishingPlace=PlaceID 
	& ('items' '{' items+=ConditionalItem+ '}')? 
	& ('knowledges' '{' knowledges+=ConditionalKnowledge+ '}')? 
	& ('itemsConsumed' '{' itemsConsumed+=ConditionalItem+ '}')?
;


/*Type booléen définit car pas présent par défaut*/
Bool: true = 'true'
	| false = 'false'
;

/*E25 */
NPC: 'npc' name=STRING 
	'obligatoryCondition'  obligatoryCondition = Condition
	& 'visibleCondition' visibleCondition=Condition
	& 'initialChoices' '{' initialChoice+=BeginningChoice+ '}'
 	;

/*E23 */
Condition: NormalDisjunctiveForm | Bool
;

/* Description des conditions*/
Comparator: lt='<' 
	| gt='>' 
	| lte='<=' 
	| gte='>=' 
	| eq='=' 
	| neq='!='
;

Negation: 'not';
AtomicCondition: {AtomicCondition} Negation? ((item=ItemID comparateur=Comparator constante=INT )| knowlegde = KnowledgeID);

Conjunction: conditions += AtomicCondition ('and' conditions += AtomicCondition)*;

NormalDisjunctiveForm: conjunctions += Conjunction ('or' conjunctions += Conjunction)*;


/* E30 */
Choice: 'choice' name=STRING
	'text' text = STRING
	& 'endingCondition' endingCondition=Condition
	& 'answers' '{' answers+=ConditionnalAnswer* '}'
;

Answer: 'answer' name=STRING 
	'action' action=ActionID 
	& 'nextChoices' '{' nextChoice += ConditionalChoice+ '}';

BeginningChoice: Choice=ChoiceID 
	'with' 'condition' condition=Condition
;


ConditionalChoice: Choice=ChoiceID
	'with' 'condition' condition=Condition
;


Action: 'action' name=STRING 
	('items' '{' items+=ConditionalItem+ '}')? 
	& ('knowledges' '{' knowledges+=ConditionalKnowledge+ '}')? 
	& ('itemsConsumed' '{' itemsConsumed+=ConditionalItem+ '}')?
;

ConditionnalAnswer: answer=Answer 
	('precedentActions' '{' precedentActions+=ActionCondition+ '}')? 
	& 'with' 'condition' condition = Condition
;

ActionCondition: action=ActionID
	'with' 'condition' condition = Condition
;

/*En soit inutile, pour se repérer plus facilement */
MapID: {MapID} STRING;
ItemID: {ItemID} STRING;
KnowledgeID: {KnowledgeID} STRING;
PlaceID: {PlaceID} STRING;
PathID: {PathID} STRING;
NPCID: {NPCID} STRING;
ChoiceID: {ChoiceID} STRING;
ActionID: {ActionID} STRING;
ExplorerID: {ExplorerID} STRING;